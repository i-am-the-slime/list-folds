\begin{frame}
\frametitle{foldr}

The \lstinline[basicstyle=\ttfamily]$foldr$ function is a machine that requires three values\footnote{similar to \lstinline[basicstyle=\ttfamily]$foldl$, although the function's arguments are swapped in order}:
\begin{enumerate}
\item \lstinline[basicstyle=\ttfamily]$f :: a -> b -> b$
\item \lstinline[basicstyle=\ttfamily]$z :: b$
\item \lstinline[basicstyle=\ttfamily]$list :: List a$
\end{enumerate}

It will give you back a value of the type \lstinline[basicstyle=\ttfamily]$b$.

\hrulefill

\lstinline[basicstyle=\ttfamily]$foldr :: (a -> b -> b) -> b -> List a -> b$

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{What does the \lstinline[basicstyle=\ttfamily]$foldr$ machine do?}

\begin{itemize}
\item Like \lstinline[basicstyle=\ttfamily]$foldl$, \lstinline[basicstyle=\ttfamily]$foldr$ takes three arguments.
\item But what this machine do to those three arguments?
\item A loop like \lstinline[basicstyle=\ttfamily]$foldl$? Something else?
\end{itemize}

\end{block}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}

The \lstinline[basicstyle=\ttfamily]$foldr$ function performs \textbf{constructor replacement}.

\end{block}

The expression \lstinline[basicstyle=\ttfamily]$foldr f z list$ replaces in \lstinline[basicstyle=\ttfamily]$list$:
\begin{enumerate}
\item Every occurrence of the cons constructor \lstinline[basicstyle=\ttfamily]$(:)$ with \lstinline[basicstyle=\ttfamily]$f$.
\item Any occurrence of the nil constructor \lstinline[basicstyle=\ttfamily]$[]$ with \lstinline[basicstyle=\ttfamily]$z$\footnote{The nil constructor may be absent \textemdash an infinite list}.
\end{enumerate}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{Constructor Replacement?}

\begin{itemize}
\item Let \lstinline[basicstyle=\ttfamily]$list = A : (B : (C : (D : [])))$
\item The expression \lstinline[basicstyle=\ttfamily, mathescape]!foldr f z list!
\item \lstinline[basicstyle=\ttfamily]$list = A `f` (B `f` (C `f` (D `f` z)))$
\end{itemize}

\end{block}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{itemize}
\item Suppose we wish to append two lists 
  \begin{itemize}
  \item \lstinline[basicstyle=\ttfamily]$list1 = U : (V : (W : []))$
  \item \lstinline[basicstyle=\ttfamily]$list2 = X : (Y : (Z : []))$
  \item \lstinline[basicstyle=\ttfamily]$result = U : (V : (W : (X : (Y : (Z : [])))))$
  \end{itemize}
\item How might the \lstinline[basicstyle=\ttfamily]$foldr$ machine help us?
\item Is this a candidate problem for constructor replacement?
\end{itemize}

\end{block}

\end{frame}


\begin{frame}[fragile]
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{lstlisting}[language=haskell]
U : (V : (W : []))
               X : (Y : (Z : []))

U : (V : (W : (X : (Y : (Z : [])))))
\end{lstlisting}

\end{block}

\end{frame}


\begin{frame}[fragile]
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{lstlisting}[language=haskell]
U : (V : (W : []))
               X : (Y : (Z : []))
               
U : (V : (W : (X : (Y : (Z : [])))))
\end{lstlisting}

\end{block}

In \lstinline[basicstyle=\ttfamily]$list1$:
\begin{itemize}
\item replace \lstinline[basicstyle=\ttfamily]$(:)$ with \lstinline[basicstyle=\ttfamily]$(:)$
\item replace \lstinline[basicstyle=\ttfamily]$[]$ with \lstinline[basicstyle=\ttfamily]$list2$
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{itemize}
\item How do we perform constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? ?$
\end{itemize}

\end{block}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{itemize}
\item How do we perform constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? ?$
\item On what are we performing constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? list1$
\end{itemize}

\end{block}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{itemize}
\item How do we perform constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? ?$
\item On what are we performing constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? list1$
\item What are we replacing the \lstinline[basicstyle=\ttfamily]$[]$ constructor with?
\item \lstinline[basicstyle=\ttfamily]$foldr ? list2 list1$
\end{itemize}

\end{block}

\end{frame}


\begin{frame}
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{itemize}
\item How do we perform constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? ?$
\item On what are we performing constructor replacement?
\item \lstinline[basicstyle=\ttfamily]$foldr ? ? list1$
\item What are we replacing the \lstinline[basicstyle=\ttfamily]$[]$ constructor with?
\item \lstinline[basicstyle=\ttfamily]$foldr ? list2 list1$
\item What are we replacing the \lstinline[basicstyle=\ttfamily]$(:)$ constructor with?
\item \lstinline[basicstyle=\ttfamily]$foldr (:) list2 list1$
\end{itemize}

\end{block}

\end{frame}


\begin{frame}[fragile]
\frametitle{foldr}

\begin{block}{example \textemdash append}

\begin{lstlisting}[language=haskell]
append list1 list2 =
  foldr (:) list2 list1
\end{lstlisting}

\end{block}

\end{frame}


\begin{frame}[fragile]
\frametitle{foldr}

\begin{block}{More examples}
You can repeat this exercise for
\begin{itemize}
\item \lstinline[basicstyle=\ttfamily]$map :: (a -> b) -> List a -> List b$
\item \lstinline[basicstyle=\ttfamily]$filter :: (a -> Bool) -> List a -> List a$
\item \lstinline[basicstyle=\ttfamily]$concat :: List (List a) -> List a$
\item \lstinline[basicstyle=\ttfamily]$concatMap :: (a -> List b) -> List a -> List b$
\item and \textbf{many more}
\end{itemize}
\end{block}

\textbf{Try it!}

\end{frame}


\begin{frame}[fragile]
\frametitle{foldr}

\begin{block}{Observations}
\begin{itemize}
\item \lstinline[basicstyle=\ttfamily]$foldr$ may work on an infinite list.
  \begin{itemize}
  \item There is no \emph{order} specified, however, there is associativity.
  \item Depends on the strictness of the given function.
  \item Replaces the \lstinline[basicstyle=\ttfamily]$[]$ constructor \emph{if it ever comes to exist}.
  \end{itemize}
\item The expression \lstinline[basicstyle=\ttfamily]$foldr (:) []$ leaves the list \emph{unchanged}.
  \begin{itemize}
  \item In other words, passing the list constructors to \lstinline[basicstyle=\ttfamily]$foldr$ produces an \emph{identity} function.
  \item A function that produces an identity, given constructors for a data type, is called its \emph{catamorphism}.
  \item \lstinline[basicstyle=\ttfamily]$foldr$ is the list catamorphism.
  \end{itemize}
\end{itemize}
\end{block}

\end{frame}
